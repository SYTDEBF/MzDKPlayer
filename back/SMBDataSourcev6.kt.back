package org.mz.mzdkplayer.tool

import android.net.Uri
import androidx.media3.common.C
import androidx.media3.common.util.Log
import androidx.media3.common.util.UnstableApi
import androidx.media3.datasource.BaseDataSource
import androidx.media3.datasource.DataSource
import androidx.media3.datasource.DataSpec
import com.hierynomus.msdtyp.AccessMask
import com.hierynomus.msfscc.fileinformation.FileStandardInformation
import com.hierynomus.mssmb2.SMB2CreateDisposition
import com.hierynomus.mssmb2.SMB2Dialect
import com.hierynomus.mssmb2.SMB2ShareAccess
import com.hierynomus.smbj.SMBClient
import com.hierynomus.smbj.SmbConfig
import com.hierynomus.smbj.auth.AuthenticationContext
import com.hierynomus.smbj.connection.Connection
import com.hierynomus.smbj.session.Session
import com.hierynomus.smbj.share.DiskShare
import com.hierynomus.smbj.share.File
import java.io.IOException
import java.util.EnumSet
import java.util.concurrent.*
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock
import kotlin.math.min

/**
 * 自定义的 SMB 数据源，用于 ExoPlayer 通过 SMB 协议读取文件。
 * 此实现针对大文件（如 80GB MKV 视频）进行了优化，特别是随机访问（seeking）性能。
 * 主要优化点：
 * 1. 使用 File.read() 直接从指定偏移量读取，避免 InputStream.skip() 的低效。
 * 2. 移除 Okio Buffer，改用内部 ByteArray 进行缓冲，减少 SMB 网络请求次数。
 * 3. 新增：使用双缓冲和后台线程实现并发预读，提高读取流畅度。
 *
 * 修复了读取大文件时可能出现的 `java.io.IOException: 从内部缓冲区读取时发生错误：期望读取 X 字节，实际读取 Y 字节` 错误。
 * 通过循环读取确保满足请求的字节数。
 */
@UnstableApi
class SmbDataSource : BaseDataSource(/* isNetwork= */ true) {
    // --- 成员变量 ---
    private var dataSpec: DataSpec? = null // 当前打开的数据规范
    private var connection: Connection? = null // SMB 连接
    private var session: Session? = null // SMB 会话
    private var share: DiskShare? = null // SMB 共享
    private var file: File? = null // 打开的 SMB 文件
    private var smbClient: SMBClient? = null // SMB 客户端实例

    // --- 并发预读相关变量 ---
    companion object {
        private const val TAG = "SmbDataSource"
        private const val DEFAULT_BUFFER_SIZE_BYTES = 2 * 1024 * 1024 // 2MB 默认缓冲区大小
        private const val PREFETCH_BUFFER_COUNT = 2 // 使用双缓冲
        private const val PREFERRED_SMB_DIALECTS = "SMB_3_1_1,SMB_3_0_2,SMB_3_0,SMB_2_1,SMB_2_0"
    }

    // 使用两个缓冲区实现双缓冲预读
    private var buffers: Array<ByteArray?> = arrayOfNulls(PREFETCH_BUFFER_COUNT)
    private var bufferLimits: IntArray = IntArray(PREFETCH_BUFFER_COUNT) // 每个缓冲区的有效数据长度
    private var bufferFileOffsets: LongArray = LongArray(PREFETCH_BUFFER_COUNT) // 每个缓冲区对应的数据在文件中的起始偏移

    private var currentBufferIndex: Int = 0 // 当前正在被 read 方法消费的缓冲区索引
    private var prefetchBufferIndex: Int = 1 // 当前正在预读的缓冲区索引

    private var currentBufferPosition: Int = 0 // 当前缓冲区内的读取位置

    private var bytesRemainingInFile: Long = 0 // 文件中剩余的总字节数 (相对于起始位置)
    private var bytesRemainingToRead: Long = 0 // 根据 DataSpec 计算出的需要读取的总字节数

    // 预读状态
    private var isPrefetching: Boolean = false
    private var isPrefetchReady: Boolean = false
    private var prefetchException: IOException? = null // 预读过程中发生的异常

    // 线程和同步
    private val lock = ReentrantLock()
    private val prefetchCondition = lock.newCondition() // 用于通知 read 线程预读完成或失败
    private var prefetchExecutor: ExecutorService? = null
    private var prefetchFuture: Future<*>? = null // 用于取消预读任务

    // 跟踪当前在 SMB 文件中的逻辑读取位置（相对于文件开头）
    private var currentFileOffset: Long = 0

    // 使用原子布尔值确保 opened 状态的线程安全 (虽然锁已足够，但保留以匹配原始设计)
    private val opened = AtomicBoolean(false)

    // --- 配置参数 ---
    private val bufferSize: Int = DEFAULT_BUFFER_SIZE_BYTES
    private val preferredSmbDialects = PREFERRED_SMB_DIALECTS
    // --- 配置结束 ---

    /**
     * 打开数据源，准备读取指定 URI 和范围的数据。
     * @param dataSpec 包含 URI、起始位置、长度等信息的数据规范
     * @return 实际可读取的字节数
     * @throws IOException 打开过程中发生错误
     */
    @Throws(IOException::class)
    override fun open(dataSpec: DataSpec): Long {
        // 通知监听器数据传输正在初始化
        transferInitializing(dataSpec)

        // 确保数据源未被打开，保证线程安全
        if (!opened.compareAndSet(false, true)) {
            throw IOException("SmbDataSource 已经被打开。")
        }

        this.dataSpec = dataSpec
        val uri = dataSpec.uri
        val host = uri.host ?: throw IOException("无效的 SMB URI: 缺少主机名")
        val path = uri.path ?: throw IOException("无效的 SMB URI: 缺少路径")
        // 分割路径以获取共享名和文件路径
        val pathSegments = path.split("/").filter { it.isNotEmpty() }
        if (pathSegments.size < 2) {
            throw IOException("无效的 SMB URI: 无法提取共享名和文件路径")
        }
        val shareName = pathSegments[0] // 第一个非空段是共享名
        val filePath = pathSegments.drop(1).joinToString("/") // 剩余部分是文件在共享中的路径

        // --- 安全警告 ---
        // 从 URI 的 userInfo 部分提取凭证是不安全的。
        // 在生产环境中应使用更安全的方法（如 Android Keystore）。
        val (username, password) = uri.userInfo?.split(":")?.let {
            if (it.size == 2) Pair(it[0], it[1]) else Pair("guest", "")
        } ?: Pair("guest", "")

        val domain = "" // 如需域名支持可在此添加

        try {
            // 配置 SMB 客户端 - 使用更优化的参数
            val dialects = preferredSmbDialects.split(",").mapNotNull {
                try {
                    SMB2Dialect.valueOf(it)
                } catch (e: IllegalArgumentException) {
                    Log.w(TAG, "忽略不支持的 SMB 方言: $it")
                    null
                }
            }.toSet()

            val config = SmbConfig.builder()
                .withDialects(EnumSet.copyOf(dialects))
                .withMultiProtocolNegotiate(true)
                .withBufferSize(4 * 1024 * 1024) // 增加协议缓冲区大小
                .build()

            // 创建 SMB 客户端并连接
            smbClient = SMBClient(config)
            connection = smbClient?.connect(host)
                ?: throw IOException("无法创建 SMB 连接")

            // 认证会话
            val authContext = AuthenticationContext(username, password.toCharArray(), domain)
            session = connection?.authenticate(authContext)
                ?: throw IOException("会话认证失败")

            // 连接到指定的共享
            share = session?.connectShare(shareName) as? DiskShare
                ?: throw IOException("连接共享失败或共享不是磁盘共享")

            // 以只读方式打开文件
            file = share?.openFile(
                filePath,
                setOf(AccessMask.GENERIC_READ), // 读取权限
                null, // 文件属性
                SMB2ShareAccess.ALL, // 共享访问模式
                SMB2CreateDisposition.FILE_OPEN, // 打开已存在文件
                null // 创建选项
            ) ?: throw IOException("打开文件失败")

            val negotiatedDialect = connection?.negotiatedProtocol?.dialect
            Log.i(TAG, "协商的 SMB 协议版本: $negotiatedDialect")

            // 获取文件总大小信息
            val fileInfo = file?.fileInformation?.standardInformation
                ?: throw IOException("获取文件信息失败")
            val fileLength = fileInfo.endOfFile

            // 验证请求的数据范围是否有效
            val startPosition = dataSpec.position
            if (startPosition < 0 || startPosition > fileLength) {
                throw IOException("无效的起始位置: $startPosition")
            }

            // 计算实际需要读取的字节数
            bytesRemainingToRead = if (dataSpec.length != C.LENGTH_UNSET.toLong()) {
                dataSpec.length
            } else {
                fileLength - startPosition
            }

            // 再次验证计算后的长度
            if (bytesRemainingToRead < 0 || startPosition + bytesRemainingToRead > fileLength) {
                throw IOException("无效的数据长度: $bytesRemainingToRead")
            }

            // 初始化内部缓冲区状态，为指定的起始位置做准备
            currentFileOffset = startPosition
            bytesRemainingInFile = fileLength - startPosition

            // 初始化缓冲区数组
            for (i in 0 until PREFETCH_BUFFER_COUNT) {
                buffers[i] = ByteArray(bufferSize)
                bufferLimits[i] = 0
                bufferFileOffsets[i] = -1
            }
            currentBufferIndex = 0
            prefetchBufferIndex = 1
            currentBufferPosition = 0

            // 初始化并发读取相关状态
            isPrefetching = false
            isPrefetchReady = false
            prefetchException = null

            // 初始化并启动预读执行器
            prefetchExecutor = Executors.newSingleThreadExecutor { r ->
                val t = Thread(r, "SmbPrefetchThread-${System.currentTimeMillis()}")
                t.isDaemon = true // 设置为守护线程，避免阻止应用退出
                t
            }

            // 通知监听器数据传输已开始
            transferStarted(dataSpec)

            // 启动第一次预读
            startPrefetch()

            return bytesRemainingToRead // 返回可读取的总字节数

        } catch (e: Exception) {
            // 如果在打开过程中发生任何错误，确保已分配的资源被释放
            closeQuietly()
            throw IOException("打开 SMB 文件时出错: ${e.message}", e)
        }
    }

    /**
     * 从数据源读取数据到指定的缓冲区。
     * @param buffer 目标缓冲区
     * @param offset 缓冲区中的起始写入偏移量
     * @param readLength 尝试读取的最大字节数
     * @return 实际读取的字节数，或 C.RESULT_END_OF_INPUT 表示结束
     * @throws IOException 读取过程中发生错误
     */
    @Throws(IOException::class)
    override fun read(buffer: ByteArray, offset: Int, readLength: Int): Int {
        // 检查数据源是否已打开
        if (!opened.get()) {
            throw IOException("数据源未打开")
        }

        // 如果没有剩余数据可读，则返回结束标志
        if (bytesRemainingToRead == 0L) {
            return C.RESULT_END_OF_INPUT
        }

        var totalBytesRead = 0
        var currentOffset = offset
        val bytesToRead = min(readLength.toLong(), bytesRemainingToRead).toInt().coerceAtLeast(0)

        if (bytesToRead == 0) {
            return 0 // 请求读取 0 字节，直接返回
        }

        try {
            while (totalBytesRead < bytesToRead) {
                val bytesNeeded = bytesToRead - totalBytesRead

                lock.withLock {
                    var currentBuffer = buffers[currentBufferIndex]
                    var currentLimit = bufferLimits[currentBufferIndex]
                    // 检查当前缓冲区是否有足够的数据
                    while (currentBufferPosition >= currentLimit) {
                        // 当前缓冲区数据已耗尽，需要切换到预读好的缓冲区
                        if (isPrefetchReady) {
                            // 预读已完成，切换缓冲区
                            val oldCurrentIndex = currentBufferIndex
                            currentBufferIndex = prefetchBufferIndex
                            prefetchBufferIndex = oldCurrentIndex

                            currentBuffer = buffers[currentBufferIndex]!!
                            currentLimit = bufferLimits[currentBufferIndex]
                            currentBufferPosition = 0

                            // 重置预读状态，准备下一次预读
                            isPrefetchReady = false
                            prefetchException = null
                            // 触发下一次预读
                            startPrefetch()

                        } else if (prefetchException != null) {
                            // 预读过程中发生错误
                            val e = prefetchException!!
                            prefetchException = null // 清除异常
                            throw e
                        } else {
                            // 预读尚未完成，等待
                            try {
                                Log.d(TAG, "等待预读完成...")
                                prefetchCondition.await() // 等待 prefetchRunnable 通知
                                Log.d(TAG, "收到预读完成通知")
                            } catch (ie: InterruptedException) {
                                Thread.currentThread().interrupt() // 重设中断状态
                                throw IOException("读取被中断", ie)
                            }
                        }
                    }

                    // 现在当前缓冲区应该有数据了
                    val bytesAvailableInBuffer = currentLimit - currentBufferPosition
                    val bytesReadFromBuffer = min(bytesNeeded, bytesAvailableInBuffer)

                    // 将数据从内部缓冲区复制到输出缓冲区
                    System.arraycopy(
                        currentBuffer!!, // Smart cast to non-null
                        currentBufferPosition,
                        buffer,
                        currentOffset,
                        bytesReadFromBuffer
                    )

                    // 更新缓冲区内部状态
                    currentBufferPosition += bytesReadFromBuffer
                    totalBytesRead += bytesReadFromBuffer
                    currentOffset += bytesReadFromBuffer
                    bytesRemainingToRead -= bytesReadFromBuffer.toLong()
                    // 通知基类已传输的字节数
                    bytesTransferred(bytesReadFromBuffer)
                } // lock.withLock 结束
            }

            return totalBytesRead

        } catch (e: Exception) {
            throw IOException("从 SMB 文件读取时出错: ${e.message}", e)
        }
    }

    /**
     * 启动后台预读任务。
     * 必须在 lock 保护下调用，或确保调用时状态一致。
     */
    private fun startPrefetch() {
        lock.withLock {
            if (!isPrefetching && !isPrefetchReady && prefetchException == null && bytesRemainingInFile > 0) {
                isPrefetching = true
                val executor = prefetchExecutor
                if (executor != null && !executor.isShutdown) {
                    prefetchFuture = executor.submit(prefetchRunnable)
                } else {
                    isPrefetching = false // Executor 不可用，重置状态
                    Log.w(TAG, "预读执行器不可用，无法启动预读")
                }
            }
        }
    }

    /**
     * 后台预读任务的 Runnable。
     */
    private val prefetchRunnable = Runnable {
        val prefetchIndex = prefetchBufferIndex
        val buffer = buffers[prefetchIndex]
        if (buffer == null) {
            lock.withLock {
                isPrefetching = false
                prefetchException = IOException("预读缓冲区未初始化")
                prefetchCondition.signalAll()
            }
            return@Runnable
        }

        val startTime = System.currentTimeMillis()
        var bytesReadFromFile = -1
        var fileOffsetForThisRead: Long = -1
        try {
            lock.withLock {
                if (!opened.get()) {
                    // 数据源已关闭，取消预读
                    isPrefetching = false
                    prefetchCondition.signalAll() // 确保等待的线程能退出
                    return@Runnable
                }
                fileOffsetForThisRead = currentFileOffset + (bytesRemainingInFile - bytesRemainingToRead) + bufferLimits[currentBufferIndex] - currentBufferPosition
                // 计算本次预读的大小
                val chunkSize = min(bufferSize.toLong(), bytesRemainingInFile - (fileOffsetForThisRead - currentFileOffset)).toInt()
                if (chunkSize <= 0) {
                    bufferLimits[prefetchIndex] = 0
                    bufferFileOffsets[prefetchIndex] = fileOffsetForThisRead
                    isPrefetching = false
                    isPrefetchReady = true
                    prefetchCondition.signalAll()
                    return@Runnable
                }

                // 执行从 SMB 文件的实际读取操作
                bytesReadFromFile = try {
                    file?.read(buffer, fileOffsetForThisRead, 0, chunkSize) ?: -1
                } catch (e: Exception) {
                    throw IOException("从 SMB 读取数据时发生错误", e)
                }
            }

            val readTime = System.currentTimeMillis() - startTime

            // 记录读取性能（只记录有意义的数据）
            if (bytesReadFromFile > 0) {
                val speed = if (readTime > 0) {
                    (bytesReadFromFile.toDouble() / readTime / 1024 / 1024) * 1000
                } else {
                    0.0
                }

                if (readTime > 100 || speed < 5.0) {
                    Log.i(
                        TAG, "预读 ${bytesReadFromFile / 1024 / 1024}MB 耗时 ${readTime}ms, " +
                                "速度: ${"%.2f".format(speed)} MB/s"
                    )
                }
            }

            lock.withLock {
                if (!opened.get()) {
                    // 数据源在读取后关闭
                    isPrefetching = false
                    prefetchCondition.signalAll()
                    return@Runnable
                }
                bufferLimits[prefetchIndex] = if (bytesReadFromFile > 0) bytesReadFromFile else 0
                bufferFileOffsets[prefetchIndex] = fileOffsetForThisRead
                isPrefetching = false
                isPrefetchReady = bytesReadFromFile > 0
                prefetchException = null
                prefetchCondition.signalAll() // 通知 read 线程
            }

        } catch (e: Exception) {
            Log.e(TAG, "预读任务发生异常", e)
            lock.withLock {
                isPrefetching = false
                // 区分是中断还是其他IO错误
                prefetchException = if (e is InterruptedException) {
                    Thread.currentThread().interrupt() // 重设中断状态
                    IOException("预读被中断", e)
                } else {
                    e as? IOException ?: IOException("预读失败: ${e.message}", e)
                }
                prefetchCondition.signalAll() // 通知 read 线程有错误
            }
        }
    }


    /**
     * 获取当前打开的数据源 URI。
     * @return 当前 URI 或 null
     */
    override fun getUri(): Uri? {
        return dataSpec?.uri
    }

    /**
     * 关闭数据源，释放所有资源。
     */
    @Throws(IOException::class)
    override fun close() {
        // 原子性地将 opened 状态从 true 设置为 false
        if (opened.compareAndSet(true, false)) {
            Log.d(TAG, "close() 被调用，开始关闭资源...")
            try {
                // 关闭预读执行器
                prefetchExecutor?.let { executor ->
                    try {
                        // 取消正在进行的预读任务
                        prefetchFuture?.cancel(true)
                        // 关闭执行器，不再接受新任务，并等待现有任务完成
                        executor.shutdown()
                        if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                            Log.w(TAG, "预读执行器未能在超时内终止，强制关闭")
                            executor.shutdownNow()
                        }
                    } catch (e: InterruptedException) {
                        Log.w(TAG, "等待预读执行器关闭时被中断", e)
                        executor.shutdownNow()
                        Thread.currentThread().interrupt()
                    } catch (e: Exception) {
                        Log.w(TAG, "关闭预读执行器时发生错误", e)
                    }
                }
            } finally {
                // 执行实际的资源关闭操作
                closeQuietly()
                // 重置内部状态
                resetInternalState()
                Log.d(TAG, "close() 完成，资源已关闭")
            }
        } else {
            Log.d(TAG, "close() 被调用，但数据源未打开或已在关闭中")
        }
    }

    /**
     * 辅助方法：静默关闭所有资源，即使发生异常也忽略。
     * 确保在 open 失败或 close 时资源得到释放。
     */
    private fun closeQuietly() {
        try {
            file?.close()
        } catch (ignored: Exception) {
            Log.w(TAG, "关闭 SMB 文件时出错", ignored)
        }
        try {
            share?.close()
        } catch (ignored: Exception) {
            Log.w(TAG, "关闭 SMB 共享时出错", ignored)
        }
        try {
            session?.close()
        } catch (ignored: Exception) {
            Log.w(TAG, "关闭 SMB 会话时出错", ignored)
        }
        try {
            connection?.close()
        } catch (ignored: Exception) {
            Log.w(TAG, "关闭 SMB 连接时出错", ignored)
        }
        try {
            smbClient?.close() // 如果 SMBClient 需要显式关闭（取决于 SMBJ 版本）
        } catch (ignored: Exception) {
            Log.w(TAG, "关闭 SMB 客户端时出错", ignored)
        }

        // 清空引用
        file = null
        share = null
        session = null
        connection = null
        smbClient = null
    }

    /**
     * 重置内部缓冲区和状态变量。
     */
    private fun resetInternalState() {
        dataSpec = null
        bytesRemainingToRead = 0
        bytesRemainingInFile = 0
        currentFileOffset = 0

        for (i in 0 until PREFETCH_BUFFER_COUNT) {
            buffers[i]?.fill(0) // 清空缓冲区内容（可选，帮助 GC）
            buffers[i] = null
            bufferLimits[i] = 0
            bufferFileOffsets[i] = -1
        }
        currentBufferIndex = 0
        prefetchBufferIndex = 1
        currentBufferPosition = 0

        isPrefetching = false
        isPrefetchReady = false
        prefetchException = null
        prefetchFuture = null
        prefetchExecutor = null // 引用置空
    }
}

/**
 * SmbDataSource 的工厂类，用于创建 SmbDataSource 实例。
 */
@UnstableApi
class SmbDataSourceFactory : DataSource.Factory {
    override fun createDataSource(): DataSource {
        return SmbDataSource()
    }
}



